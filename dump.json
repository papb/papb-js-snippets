[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "src/.eslintrc.js",
    "content": "module.exports = {\n    \"rules\": {\n        \"strict\": \"off\"\n    },\n    \"globals\": {\n        \"snippets\": false\n    }\n};",
    "static": true,
    "longname": "src/.eslintrc.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "file",
    "name": "src/add-script.js",
    "content": "/**\n * Adds an script from the given src to the page.\n * \n * WARNING: This is incredibly dangerous. Only use this if you are sure\n * you can trust the given src.\n * \n * @param {DOCUMENT} document The document object.\n * @param {string} src The src of the script to be added.\n * \n * @return {Promise} A promise that resolves when the script finishes loading.\n */\nconst addScript = function(document, src) {\n    if (typeof src !== \"string\") throw new Error(\"Invalid src argument: must be a string.\");\n    return new Promise(resolve => {\n        const script = document.createElement('script');\n        script.setAttribute('src', src);\n        script.onload = resolve;\n        document.body.appendChild(script);\n    });\n};\n\n/**\n * Adds an script with the given content to the page.\n * \n * WARNING: This is incredibly dangerous. Only use this if you know\n * exactly what you're doing, and if the content is a hardcoded string,\n * and definitely nothing that comes from user input.\n * \n * The given content starts executing immediately. This function returns\n * immediately unless the given content code hangs or throws (in which\n * case this function will also hang/throw respectively).\n * \n * @param {DOCUMENT} document The document object.\n * @param {string} content The content to be put in the script.\n */\naddScript.inline = function(document, content) {\n    if (typeof content !== \"string\") throw new Error(\"Invalid content argument: must be a string.\");\n    return new Promise(resolve => {\n        const script = document.createElement('script');\n        try {\n            script.appendChild(document.createTextNode(content));\n        } catch (e) {\n            script.text = content;\n        }\n        document.body.appendChild(script);\n        resolve();\n    });\n};\n\n/* test */ module.exports = {\n    snippet: addScript,\n    snippetName: \"addScript\",\n    snippetTest: t => {\n        t.is(typeof addScript, \"function\");\n        t.is(typeof addScript.inline, \"function\");\n    }\n};",
    "static": true,
    "longname": "src/add-script.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2,
    "kind": "function",
    "name": "addScript",
    "memberof": "src/add-script.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/add-script.js~addScript",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/add-script.js",
    "importStyle": null,
    "description": "Adds an script from the given src to the page.\n\nWARNING: This is incredibly dangerous. Only use this if you are sure\nyou can trust the given src.",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "DOCUMENT"
        ],
        "spread": false,
        "optional": false,
        "name": "document",
        "description": "The document object."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "src",
        "description": "The src of the script to be added."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise that resolves when the script finishes loading."
    }
  },
  {
    "__docId__": 3,
    "kind": "function",
    "name": "inline",
    "memberof": "src/add-script.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/add-script.js~inline",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/add-script.js",
    "importStyle": null,
    "description": "Adds an script with the given content to the page.\n\nWARNING: This is incredibly dangerous. Only use this if you know\nexactly what you're doing, and if the content is a hardcoded string,\nand definitely nothing that comes from user input.\n\nThe given content starts executing immediately. This function returns\nimmediately unless the given content code hangs or throws (in which\ncase this function will also hang/throw respectively).",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "DOCUMENT"
        ],
        "spread": false,
        "optional": false,
        "name": "document",
        "description": "The document object."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "content",
        "description": "The content to be put in the script."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "file",
    "name": "src/array-has.js",
    "content": "/**\n * Checks whether the given array contains the given value(s) or not. The value(s) is/are\n * searched in O(n*k) using javascript strict equality operator (`===`), where n is the\n * array length and k is the amount of passed values.\n * \n * This function returs true if and only if all given values are present in the array.\n * \n * @param {Array} array The array to be checked\n * @param {...*} values The value(s) to be searched in the array\n * \n * @returns {boolean} A boolean that indicates whether the array contains the value.\n * \n * @example\n * \n * ```\n * arrayHas([1, 2, 3], 1); // true\n * arrayHas([1, 2, 3], 2, 1, 1); // true\n * arrayHas([1, 2, 3], 2, 4, 1); // false\n * arrayHas([1, 2, 3], [1, 2, 3]); // false\n * ```\n */\nconst arrayHas = function(array, ...values) {\n    return values.every(value => array.some(obj => obj === value));\n};\n\n/* test */ module.exports = {\n    snippet: arrayHas,\n    snippetName: \"arrayHas\",\n    snippetTest: t => {\n        t.is(arrayHas([1, 2, 3], 1), true);\n        t.is(arrayHas([1, 2, 3], 2, 1, 1), true);\n        t.is(arrayHas([1, 2, 3], 2, 4, 1), false);\n        t.is(arrayHas([1, 2, 3], [1, 2, 3]), false);\n    }\n};",
    "static": true,
    "longname": "src/array-has.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 5,
    "kind": "function",
    "name": "arrayHas",
    "memberof": "src/array-has.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/array-has.js~arrayHas",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/array-has.js",
    "importStyle": null,
    "description": "Checks whether the given array contains the given value(s) or not. The value(s) is/are\nsearched in O(n*k) using javascript strict equality operator (`===`), where n is the\narray length and k is the amount of passed values.\n\nThis function returs true if and only if all given values are present in the array.",
    "examples": [
      "\n```\narrayHas([1, 2, 3], 1); // true\narrayHas([1, 2, 3], 2, 1, 1); // true\narrayHas([1, 2, 3], 2, 4, 1); // false\narrayHas([1, 2, 3], [1, 2, 3]); // false\n```"
    ],
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} A boolean that indicates whether the array contains the value."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "The array to be checked"
      },
      {
        "nullable": null,
        "types": [
          "...*"
        ],
        "spread": true,
        "optional": false,
        "name": "values",
        "description": "The value(s) to be searched in the array"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "A boolean that indicates whether the array contains the value."
    }
  },
  {
    "__docId__": 6,
    "kind": "file",
    "name": "src/array-to-map.js",
    "content": "/**\n * Creates an ES6 Map object from an array, where each object's key is defined\n * by the keyMaker function.\n * \n * @param {Array} array The source array.\n * @param {function} keyMaker The function that takes an element of the array and\n * returns a key to be used in the map for that element. If this function returns\n * a repeated key for two different objects, the former will be overwritten and\n * only the latter value will remain in the map.\n * \n * @returns {Map} A map whose keys are the results of calling keyMaker on the array\n * elements and whose values are the array elements.\n * \n * @example\n * \n * ```\n * let array = [{ a: 3 }, { a: 1, d: 2 }, { a: 5, b: 3 }];\n * let map = arrayToMap(array, x => x.a);\n * map.get(3); // { a: 3 }\n * map.get(1); // { a: 1, d: 2 }\n * map.get(5); // { a: 5, b: 3 }\n * ```\n */\nconst arrayToMap = function(array, keyMaker) {\n    return new Map(array.map(x => [keyMaker(x), x]));\n};\n\n/* test */ module.exports = {\n    snippet: arrayToMap,\n    snippetName: \"arrayToMap\",\n    snippetTest: t => {\n        const array = [{ a: 3 }, { a: 1, d: 2 }, { a: 5, b: 3 }];\n        const map = arrayToMap(array, x => x.a);\n        t.deepEqual(map.get(3), { a: 3 });\n        t.deepEqual(map.get(1), { a: 1, d: 2 });\n        t.deepEqual(map.get(5), { a: 5, b: 3 });\n    }\n};",
    "static": true,
    "longname": "src/array-to-map.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 7,
    "kind": "function",
    "name": "arrayToMap",
    "memberof": "src/array-to-map.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/array-to-map.js~arrayToMap",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/array-to-map.js",
    "importStyle": null,
    "description": "Creates an ES6 Map object from an array, where each object's key is defined\nby the keyMaker function.",
    "examples": [
      "\n```\nlet array = [{ a: 3 }, { a: 1, d: 2 }, { a: 5, b: 3 }];\nlet map = arrayToMap(array, x => x.a);\nmap.get(3); // { a: 3 }\nmap.get(1); // { a: 1, d: 2 }\nmap.get(5); // { a: 5, b: 3 }\n```"
    ],
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Map} A map whose keys are the results of calling keyMaker on the array\nelements and whose values are the array elements."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "The source array."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "keyMaker",
        "description": "The function that takes an element of the array and\nreturns a key to be used in the map for that element. If this function returns\na repeated key for two different objects, the former will be overwritten and\nonly the latter value will remain in the map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Map"
      ],
      "spread": false,
      "description": "A map whose keys are the results of calling keyMaker on the array\nelements and whose values are the array elements."
    }
  },
  {
    "__docId__": 8,
    "kind": "file",
    "name": "src/array-to-picker-function.js",
    "content": "/**\n * Creates a function that yields the elements of the given array in order when called with\n * different arguments (and is idempotent). If the end of the array is reached, picking will\n * restart from the beginning. The behaviour of this function is better understood by example\n * (which can be found below).\n * \n * @param {Array} array The source array\n * @return {function} The picker function\n * \n * @example\n * \n * ```\n * let f = arrayToPickerFunction([1, 2, 3]);\n * let w = 55;\n * let x = {};\n * let y = {};\n * let z = \"something\";\n * f(w); // 1\n * f(x); // 2\n * f(w); // 1\n * f(y); // 3\n * f(z); // 1\n * f(y); // 3\n * f(y); // 3\n * f(x); // 2\n * f(z); // 1\n * ```\n */\nconst arrayToPickerFunction = function(array) {\n    if (!Array.isArray(array)) throw new TypeError(\"Parameter must be an array.\");\n    const localArray = array.slice(); // If the given array changes, this won't change.\n    const indexMap = new Map();\n    let nextIndex = 0;\n    return function(obj) {\n        if (!indexMap.has(obj)) {\n            indexMap.set(obj, nextIndex);\n            nextIndex = (nextIndex + 1) % localArray.length;\n        }\n        return localArray[indexMap.get(obj)];\n    };\n};\n\n/* test */ module.exports = {\n    snippet: arrayToPickerFunction,\n    snippetName: \"arrayToPickerFunction\",\n    snippetTest: t => {\n        const f = arrayToPickerFunction([1, 2, 3]);\n        const w = 55;\n        const x = {};\n        const y = {};\n        const z = \"something\";\n        t.is(f(w), 1);\n        t.is(f(x), 2);\n        t.is(f(w), 1);\n        t.is(f(y), 3);\n        t.is(f(z), 1);\n        t.is(f(y), 3);\n        t.is(f(y), 3);\n        t.is(f(x), 2);\n        t.is(f(z), 1);\n    }\n};",
    "static": true,
    "longname": "src/array-to-picker-function.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 9,
    "kind": "function",
    "name": "arrayToPickerFunction",
    "memberof": "src/array-to-picker-function.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/array-to-picker-function.js~arrayToPickerFunction",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/array-to-picker-function.js",
    "importStyle": null,
    "description": "Creates a function that yields the elements of the given array in order when called with\ndifferent arguments (and is idempotent). If the end of the array is reached, picking will\nrestart from the beginning. The behaviour of this function is better understood by example\n(which can be found below).",
    "examples": [
      "\n```\nlet f = arrayToPickerFunction([1, 2, 3]);\nlet w = 55;\nlet x = {};\nlet y = {};\nlet z = \"something\";\nf(w); // 1\nf(x); // 2\nf(w); // 1\nf(y); // 3\nf(z); // 1\nf(y); // 3\nf(y); // 3\nf(x); // 2\nf(z); // 1\n```"
    ],
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "The source array"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": "The picker function"
    }
  },
  {
    "__docId__": 10,
    "kind": "file",
    "name": "src/base64-substitution-cipher.js",
    "content": "/**\n * Perform a substitution cipher on any string by first converting the string to Base64. Note: this is a very weak\n * encryption algorithm that shouldn't be used for security purposes.\n * \n * The plaintext alphabet used is \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\" (after the\n * string is converted to Base64).\n * \n * To decrypt, set the `reverse` option to true.\n * \n * @requires snippet:simple-substitution-cipher\n * @requires npm:js-base64 by dankogai\n *\n * @param {string} str The string to be encrypted / decrypted.\n * \n * @param {Object} [options] An object to provide options.\n * \n * @param {string} [options.ciphertextAlphabet=\"hrVtM=TYziLNIemw39dBXDj18lykGUPosR20+fEK6buFCcJpZgqWH/xQ57S4nvaAO\"]\n * The ciphertext alphabet to be used. Must be an anagram of the plaintext alphabet.\n * \n * @param {boolean} [options.reverse=false] Whether or not to reverse the encryption, i.e., to decrypt. Setting this\n * to true will cause the cipher to be undone followed by the Base64 decode of the result.\n * \n * @throws {Error} If the `reverse` option is set to true and the passed string is not a valid Base64 string.\n * \n * @see https://en.wikipedia.org/wiki/Substitution_cipher\n * @see https://en.wikipedia.org/wiki/Base64\n * \n * @example\n * \n * ```\n * base64SubstitutionCipher(\"hello! ^^\"); // \"yTDCkTnRz=7P\"\n * base64SubstitutionCipher(\"yTDCkTnRz=7P\", { reverse: true }); // \"hello! ^^\"\n * base64SubstitutionCipher(\"hello! ^^\", {\n *     ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\"\n * }); // \"lf1HPfXTQthD\"\n * base64SubstitutionCipher(\"lf1HPfXTQthD\", {\n *     ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\",\n *     reverse: true\n * }); // \"hello! ^^\"\n * ```\n */\nconst base64SubstitutionCipher = (function() {\n\n    const Base64 = require('js-base64').Base64;\n\n    function areAnagrams(str1, str2) {\n        return str1.split(\"\").sort().join(\"\") === str2.split(\"\").sort().join(\"\");\n    }\n\n    return function base64SubstitutionCipher(str, options = {}) {\n        const plaintextAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        let ciphertextAlphabet = options.ciphertextAlphabet;\n        let reverse = options.reverse;\n\n        if (ciphertextAlphabet === undefined) ciphertextAlphabet = \"hrVtM=TYziLNIemw39dBXDj18lykGUPosR20+fEK6buFCcJpZgqWH/xQ57S4nvaAO\";\n        if (reverse === undefined) reverse = false;\n        if (typeof ciphertextAlphabet !== \"string\") throw new Error(\"Ciphertext alphabet must be a string.\");\n        if (!areAnagrams(plaintextAlphabet, ciphertextAlphabet)) {\n            throw new Error(\"Ciphertext alphabet and plaintext alphabet must be anagrams.\");\n        }\n\n        if (!reverse) str = Base64.encode(str);\n        const result = snippets.simpleSubstitutionCipher(str, { plaintextAlphabet, ciphertextAlphabet, reverse });\n        if (reverse && result.indexOf(\"?\") !== -1) throw new Error(\"The passed string is not a valid Base64 string.\");\n        return reverse ? Base64.decode(result) : result;\n    };\n\n})();\n\n/* test */ module.exports = {\n    snippet: base64SubstitutionCipher,\n    snippetName: \"base64SubstitutionCipher\",\n    snippetTest: t => {\n        t.is(base64SubstitutionCipher(\"hello! ^^\"), \"yTDCkTnRz=7P\");\n        t.is(base64SubstitutionCipher(\"yTDCkTnRz=7P\", { reverse: true }), \"hello! ^^\");\n        t.is(base64SubstitutionCipher(\"hello! ^^\", {\n            ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\"\n        }), \"lf1HPfXTQthD\");\n        t.is(base64SubstitutionCipher(\"lf1HPfXTQthD\", {\n            ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\",\n            reverse: true\n        }), \"hello! ^^\");\n        t.throws(() => base64SubstitutionCipher(\"hello! ^^\", { reverse: true }));\n    }\n};",
    "static": true,
    "longname": "src/base64-substitution-cipher.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 11,
    "kind": "variable",
    "name": "base64SubstitutionCipher",
    "memberof": "src/base64-substitution-cipher.js",
    "static": true,
    "longname": "src/base64-substitution-cipher.js~base64SubstitutionCipher",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/base64-substitution-cipher.js",
    "importStyle": null,
    "description": "Perform a substitution cipher on any string by first converting the string to Base64. Note: this is a very weak\nencryption algorithm that shouldn't be used for security purposes.\n\nThe plaintext alphabet used is \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\" (after the\nstring is converted to Base64).\n\nTo decrypt, set the `reverse` option to true.",
    "examples": [
      "\n```\nbase64SubstitutionCipher(\"hello! ^^\"); // \"yTDCkTnRz=7P\"\nbase64SubstitutionCipher(\"yTDCkTnRz=7P\", { reverse: true }); // \"hello! ^^\"\nbase64SubstitutionCipher(\"hello! ^^\", {\n    ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\"\n}); // \"lf1HPfXTQthD\"\nbase64SubstitutionCipher(\"lf1HPfXTQthD\", {\n    ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\",\n    reverse: true\n}); // \"hello! ^^\"\n```"
    ],
    "see": [
      "https://en.wikipedia.org/wiki/Substitution_cipher",
      "https://en.wikipedia.org/wiki/Base64"
    ],
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "snippet:simple-substitution-cipher"
      },
      {
        "tagName": "@requires",
        "tagValue": "npm:js-base64 by dankogai"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "The string to be encrypted / decrypted."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "An object to provide options."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.ciphertextAlphabet",
        "description": "The ciphertext alphabet to be used. Must be an anagram of the plaintext alphabet."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.reverse",
        "description": "Whether or not to reverse the encryption, i.e., to decrypt. Setting this\nto true will cause the cipher to be undone followed by the Base64 decode of the result."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the `reverse` option is set to true and the passed string is not a valid Base64 string."
      }
    ]
  },
  {
    "__docId__": 12,
    "kind": "file",
    "name": "src/browser-secure-random.js",
    "content": "/**\r\n * Cryptographycally secure equivalent to Math.random() in browsers.\r\n * \r\n * @return {number} A number between 0 (inclusive) and 1 (exclusive)\r\n */\r\nconst browserSecureRandom = function() {\r\n    /* global window */\r\n    const temp = new Uint32Array(1);\r\n    window.crypto.getRandomValues(temp);\r\n    return temp / 0x100000000;\r\n};\r\n\r\n/* test */ module.exports = {\r\n    snippet: browserSecureRandom,\r\n    snippetName: \"browserSecureRandom\",\r\n    snippetTest: t => {\r\n        t.pass();\r\n    }\r\n};",
    "static": true,
    "longname": "src/browser-secure-random.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 13,
    "kind": "function",
    "name": "browserSecureRandom",
    "memberof": "src/browser-secure-random.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/browser-secure-random.js~browserSecureRandom",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/browser-secure-random.js",
    "importStyle": null,
    "description": "Cryptographycally secure equivalent to Math.random() in browsers.",
    "lineNumber": 6,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "A number between 0 (inclusive) and 1 (exclusive)"
    }
  },
  {
    "__docId__": 14,
    "kind": "file",
    "name": "src/call-sequentially.js",
    "content": "/**\n * Takes an array of functions and calls them sequentially. If any of these\n * functions return a promise, the promise is waited for, before calling the next\n * functions.\n * \n * @param {function[]} functions The array of functions to be called sequentially\n * \n * @return {Promise} A promise that resolves when the last call is done and\n * rejects with an error if any of the functions throw an error (in which case\n * the sequence is terminated immediately).\n */\nconst callSequentially = function(functions) {\n    let promiseChain = Promise.resolve();\n    functions.forEach(f => {\n        promiseChain = promiseChain.then(f);\n    });\n    return promiseChain;\n};\n\n/* test */ module.exports = {\n    snippet: callSequentially,\n    snippetName: \"callSequentially\",\n    snippetTest: t => {\n        let temp = 100;\n        return callSequentially([\n            () => { temp += 5; },\n            () => { temp *= 2; },\n            () => snippets.wait(50).then(() => { temp *= 3; }),\n            () => { temp += 11; }\n        ]).then(() => {\n            t.is(temp, 641);\n        });\n    }\n};",
    "static": true,
    "longname": "src/call-sequentially.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 15,
    "kind": "function",
    "name": "callSequentially",
    "memberof": "src/call-sequentially.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/call-sequentially.js~callSequentially",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/call-sequentially.js",
    "importStyle": null,
    "description": "Takes an array of functions and calls them sequentially. If any of these\nfunctions return a promise, the promise is waited for, before calling the next\nfunctions.",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "function[]"
        ],
        "spread": false,
        "optional": false,
        "name": "functions",
        "description": "The array of functions to be called sequentially"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise that resolves when the last call is done and\nrejects with an error if any of the functions throw an error (in which case\nthe sequence is terminated immediately)."
    }
  },
  {
    "__docId__": 16,
    "kind": "file",
    "name": "src/colorize-console.js",
    "content": "/**\r\n * Colorizes `console.warn` and `console.error` and adds the extra methods\r\n * `console.blue`, `console.green` and `console.gray`.\r\n * \r\n * @requires npm:chalk\r\n */\r\nconst colorizeConsole = function() {\r\n    const chalk = require(\"chalk\");\r\n\r\n    function colorize(args, color) {\r\n        return args.map(arg => {\r\n            if (typeof arg !== \"string\") return arg;\r\n            return chalk[color](arg);\r\n        });\r\n    }\r\n\r\n    const originalConsoleWarn = console.warn.bind(console);\r\n    const originalConsoleError = console.error.bind(console);\r\n\r\n    console.warn = (...args) => originalConsoleWarn(...colorize(args, \"yellow\"));\r\n    console.error = (...args) => originalConsoleError(...colorize(args, \"red\"));\r\n    console.blue = (...args) => console.log(...colorize(args, \"blue\"));\r\n    console.green = (...args) => console.log(...colorize(args, \"green\"));\r\n    console.gray = (...args) => console.log(...colorize(args, \"gray\"));\r\n};\r\n\r\n/* test */ module.exports = {\r\n    snippet: colorizeConsole,\r\n    snippetName: \"colorizeConsole\",\r\n    snippetTest: t => {\r\n        t.pass();\r\n    }\r\n};",
    "static": true,
    "longname": "src/colorize-console.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 17,
    "kind": "function",
    "name": "colorizeConsole",
    "memberof": "src/colorize-console.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/colorize-console.js~colorizeConsole",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/colorize-console.js",
    "importStyle": null,
    "description": "Colorizes `console.warn` and `console.error` and adds the extra methods\n`console.blue`, `console.green` and `console.gray`.",
    "lineNumber": 7,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "npm:chalk"
      }
    ],
    "params": []
  },
  {
    "__docId__": 18,
    "kind": "file",
    "name": "src/count-occurrences.js",
    "content": "/**\n * Counts how many times each element of the array occurs in it.\n * \n * @param {Array} array\n * \n * @return {Map} A map that maps elements to the amount of occurrences.\n * \n * @example\n * \n * ```\n * let array = [\"a\", 1, null, \"b\", null, \"b\", \"a\", \"a\"];\n * let countMap = countOccurrences(array);\n * countMap.get(\"a\"); // 3\n * countMap.get(1); // 1\n * countMap.get(null); // 2\n * countMap.get(\"b\"); // 2\n * ```\n */\nconst countOccurrences = function(array) {\n    const result = new Map();\n    for (const element of array) {\n        if (result.has(element)) {\n            result.set(element, result.get(element) + 1);\n        } else {\n            result.set(element, 1);\n        }\n    }\n    return result;\n};\n\n/* test */ module.exports = {\n    snippet: countOccurrences,\n    snippetName: \"countOccurrences\",\n    snippetTest: t => {\n        const array = [\"a\", 1, null, \"b\", null, \"b\", \"a\", \"a\"];\n        const countMap = countOccurrences(array);\n        t.is(countMap.get(\"a\"), 3);\n        t.is(countMap.get(1), 1);\n        t.is(countMap.get(null), 2);\n        t.is(countMap.get(\"b\"), 2);\n    }\n};",
    "static": true,
    "longname": "src/count-occurrences.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 19,
    "kind": "function",
    "name": "countOccurrences",
    "memberof": "src/count-occurrences.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/count-occurrences.js~countOccurrences",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/count-occurrences.js",
    "importStyle": null,
    "description": "Counts how many times each element of the array occurs in it.",
    "examples": [
      "\n```\nlet array = [\"a\", 1, null, \"b\", null, \"b\", \"a\", \"a\"];\nlet countMap = countOccurrences(array);\ncountMap.get(\"a\"); // 3\ncountMap.get(1); // 1\ncountMap.get(null); // 2\ncountMap.get(\"b\"); // 2\n```"
    ],
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Map"
      ],
      "spread": false,
      "description": "A map that maps elements to the amount of occurrences."
    }
  },
  {
    "__docId__": 20,
    "kind": "file",
    "name": "src/deduplicate-by.js",
    "content": "/**\n * Produces an array which contains a subset of the given array, deduplicating\n * elements by the values each yield when passed to the valuePicker function.\n * In other words, produces a subset of the array by keeping only one element\n * per value yielded when passed to the valuePicker function.\n * \n * @requires snippet:replace-array\n * \n * @param {Array} array The array to the deduplicated\n * \n * @param {function} valuePicker A function that when applied to each value of\n * the array returns another value to be used for the deduplication. This function\n * is called only once per value.\n * \n * @param {boolean} [inPlace=false] If true, alters the given array instead of\n * creating a new one.\n * \n * @returns {Array} The resulting array (if inPlace is true, this is the same as\n * the passed array, otherwise it is a new array).\n * \n * @example\n * \n * ```\n * let array = [{ a: 1, b: 2 }, { a: 3, b: 2 }];\n * deduplicateBy(array, x => x.b, true);\n * console.log(array); // [{ a: 1, b: 2 }]\n * ```\n */\nconst deduplicateBy = function(array, valuePicker, inPlace = false) {\n    let result = [];\n    const helperArray = array.map(x => ({ value: x, picked: valuePicker(x) }));\n    helperArray.forEach(x => {\n        if (!result.find(r => r.picked === x.picked)) result.push(x);\n    });\n    result = result.map(x => x.value);\n    if (inPlace) return snippets.replaceArray(array, result);\n    return result;\n};\n\n/* test */ module.exports = {\n    snippet: deduplicateBy,\n    snippetName: \"deduplicateBy\",\n    snippetTest: t => {\n        const array = [{ a: 1, b: 2 }, { a: 3, b: 2 }];\n        deduplicateBy(array, x => x.a, true);\n        t.deepEqual(array, [{ a: 1, b: 2 }, { a: 3, b: 2 }]);\n        deduplicateBy(array, x => x.b, true);\n        t.deepEqual(array, [{ a: 1, b: 2 }]);\n    }\n};",
    "static": true,
    "longname": "src/deduplicate-by.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 21,
    "kind": "function",
    "name": "deduplicateBy",
    "memberof": "src/deduplicate-by.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/deduplicate-by.js~deduplicateBy",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/deduplicate-by.js",
    "importStyle": null,
    "description": "Produces an array which contains a subset of the given array, deduplicating\nelements by the values each yield when passed to the valuePicker function.\nIn other words, produces a subset of the array by keeping only one element\nper value yielded when passed to the valuePicker function.",
    "examples": [
      "\n```\nlet array = [{ a: 1, b: 2 }, { a: 3, b: 2 }];\ndeduplicateBy(array, x => x.b, true);\nconsole.log(array); // [{ a: 1, b: 2 }]\n```"
    ],
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "snippet:replace-array"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Array} The resulting array (if inPlace is true, this is the same as\nthe passed array, otherwise it is a new array)."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "The array to the deduplicated"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "valuePicker",
        "description": "A function that when applied to each value of\nthe array returns another value to be used for the deduplication. This function\nis called only once per value."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "inPlace",
        "description": "If true, alters the given array instead of\ncreating a new one."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "The resulting array (if inPlace is true, this is the same as\nthe passed array, otherwise it is a new array)."
    }
  },
  {
    "__docId__": 22,
    "kind": "file",
    "name": "src/deep-clone.js",
    "content": "/**\n * Deep clone an object without circular references. Everything whose typeof is\n * not \"object\" will be copied by reference (without cloning).\n * \n * @requires npm:is-circular^1.0.0\n * @requires snippet:map-object\n * \n * @param {object} object The object to be cloned\n * \n * @return {object} The cloned object\n * \n * @throws {Error} If the object has circular references\n */\nconst deepClone = (() => {\n    const isCircular = require('is-circular');\n    return function(obj) {\n        if (obj === null) return null;\n        if (typeof obj !== \"object\") return obj;\n        if (isCircular(obj)) throw new Error(\"Unable to deep clone with circular references.\");\n        if (Array.isArray(obj)) return obj.map(deepClone);\n        return snippets.mapObject(obj, deepClone);\n    };\n})();\n\n/* test */ module.exports = {\n    snippet: deepClone,\n    snippetName: \"deepClone\",\n    snippetTest: t => {\n        const obj = { a: 1, b: 2, c: [{ d: 3, e: 4 }] };\n        const clone = deepClone(obj);\n        t.not(clone, obj);\n        t.not(clone.c, obj.c);\n        t.not(clone.c[0], obj.c[0]);\n        t.deepEqual(clone, obj);\n        obj.f = obj;\n        t.throws(() => {\n            deepClone(obj);\n        });\n    }\n};",
    "static": true,
    "longname": "src/deep-clone.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 23,
    "kind": "variable",
    "name": "deepClone",
    "memberof": "src/deep-clone.js",
    "static": true,
    "longname": "src/deep-clone.js~deepClone",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/deep-clone.js",
    "importStyle": null,
    "description": "Deep clone an object without circular references. Everything whose typeof is\nnot \"object\" will be copied by reference (without cloning).",
    "lineNumber": 14,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "npm:is-circular^1.0.0"
      },
      {
        "tagName": "@requires",
        "tagValue": "snippet:map-object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": "The object to be cloned"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The cloned object"
    },
    "type": {
      "types": [
        "*"
      ]
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the object has circular references"
      }
    ]
  },
  {
    "__docId__": 24,
    "kind": "file",
    "name": "src/download-file.js",
    "content": "/**\n * Downloads a file from a given URL and saves it.\n * \n * @requires fs-jetpack^2.2.0\n * @requires request^2.88.0\n * \n * @param {string} sourceURL The URL containing the file to be downloaded.\n * @param {string} [destinationFilePath] The path (including filename) for\n * the file to be saved. If omitted, defaults to the same filename given in\n * the sourceURL.\n * \n * @return {Promise} A promise that resolves when everything is done or reject\n * with any error that happens in the process.\n */\nconst downloadFile = function(sourceURL, destinationFilePath = null) {\n    const jetpack = require(\"fs-jetpack\");\n    const request = require(\"request\");\n\n    return Promise.resolve().then(() => {\n        // Ensure destinationFilePath is valid\n        if (!destinationFilePath) {\n            destinationFilePath = /[^\\\\/]*$/.exec(sourceURL);\n            if (destinationFilePath) destinationFilePath = destinationFilePath[0];\n        }\n        if (!destinationFilePath) throw new Error(\"Unable to parse default destination file name.\");\n        if (typeof destinationFilePath !== \"string\") throw new TypeError(\"Invalid destinationFilePath: must be a string.\");\n    }).then(() => {\n        // Ensure the path to the file exists and that the file does not\n        // (i.e. that it gets overwritten if exists).\n        return jetpack.writeAsync(destinationFilePath, \"\");\n    }).then(() => {\n        return jetpack.removeAsync(destinationFilePath);\n    }).then(() => {\n        return new Promise((resolve, reject) => {\n            request.get(sourceURL)\n                .on(\"error\", reject)\n                .pipe(jetpack.createWriteStream(destinationFilePath))\n                .on(\"error\", reject)\n                .on(\"finish\", resolve);\n        });\n    });\n};\n\n/* test */ module.exports = {\n    snippet: downloadFile,\n    snippetName: \"downloadFile\",\n    snippetTest: t => {\n        const jetpack = require(\"fs-jetpack\");\n        t.plan(3);\n\n        const URL = \"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.slim.min.js\";\n        return downloadFile(URL).then(() => {\n            t.true(jetpack.exists(\"jquery.slim.min.js\") === \"file\");\n            const hash = snippets.sha256(jetpack.read(\"jquery.slim.min.js\"));\n            t.is(hash, \"45fe0169d7f20adb2f1e63bcf4151971b62f34dbd9bce4f4f002df133bc2b03d\");\n            jetpack.remove(\"jquery.slim.min.js\");\n            t.pass();\n        });\n    }\n};",
    "static": true,
    "longname": "src/download-file.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 25,
    "kind": "function",
    "name": "downloadFile",
    "memberof": "src/download-file.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/download-file.js~downloadFile",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/download-file.js",
    "importStyle": null,
    "description": "Downloads a file from a given URL and saves it.",
    "lineNumber": 15,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "fs-jetpack^2.2.0"
      },
      {
        "tagName": "@requires",
        "tagValue": "request^2.88.0"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceURL",
        "description": "The URL containing the file to be downloaded."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "destinationFilePath",
        "description": "The path (including filename) for\nthe file to be saved. If omitted, defaults to the same filename given in\nthe sourceURL."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise that resolves when everything is done or reject\nwith any error that happens in the process."
    }
  },
  {
    "__docId__": 26,
    "kind": "file",
    "name": "src/ellipsis.js",
    "content": "/**\n * Shorten a string to a certain length (truncating it and adding \"...\").\n * \n * @param {string} str The string to be shortened\n * @param {int} length The desired length (including the \"...\")\n * @return {string} A string whose length is at most the given length.\n * \n * @example\n * \n * ```\n * ellipsis(\"Hello World!\", 11); // \"Hello Wo...\"\n * ellipsis(\"Hello\", 8); // \"Hello\"\n * ellipsis(\"Hello World\", 11); // \"Hello World\"\n * ```\n */\nconst ellipsis = function(str, maxlength) {\n    return str.length > maxlength ? str.substring(0, maxlength - 3) + \"...\" : str;\n};\n\n/* test */ module.exports = {\n    snippet: ellipsis,\n    snippetName: \"ellipsis\",\n    snippetTest: t => {\n        t.is(ellipsis(\"Hello World!\", 11), \"Hello Wo...\");\n        t.is(ellipsis(\"Hello\", 8), \"Hello\");\n        t.is(ellipsis(\"Hello World\", 11), \"Hello World\");\n    }\n};",
    "static": true,
    "longname": "src/ellipsis.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 27,
    "kind": "function",
    "name": "ellipsis",
    "memberof": "src/ellipsis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ellipsis.js~ellipsis",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/ellipsis.js",
    "importStyle": null,
    "description": "Shorten a string to a certain length (truncating it and adding \"...\").",
    "examples": [
      "\n```\nellipsis(\"Hello World!\", 11); // \"Hello Wo...\"\nellipsis(\"Hello\", 8); // \"Hello\"\nellipsis(\"Hello World\", 11); // \"Hello World\"\n```"
    ],
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "The string to be shortened"
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "length",
        "description": "The desired length (including the \"...\")"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A string whose length is at most the given length."
    }
  },
  {
    "__docId__": 28,
    "kind": "file",
    "name": "src/exec-async.js",
    "content": "/**\r\n * Executes a system command and returns a promise for its stdout output.\r\n * Output to stderr is ignored.\r\n * \r\n * @param {string} command The command to execute\r\n * \r\n * @return {Promise<string>} A promise for the output. Rejects if the command\r\n * exits with nonzero code.\r\n */\r\nconst execAsync = function(command) {\r\n    const { exec } = require('child_process');\r\n    return new Promise((resolve, reject) => {\r\n        exec(command, (err, stdout, stderr) => { // eslint-disable-line no-unused-vars\r\n            if (err) {\r\n                reject(err);\r\n            } else {\r\n                resolve(stdout);\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\n/* test */ module.exports = {\r\n    snippet: execAsync,\r\n    snippetName: \"execAsync\",\r\n    snippetTest: t => {\r\n        t.plan(2);\r\n        return Promise.all([\r\n            execAsync(\"node -v\").then(result => {\r\n                t.true(/\\d+\\.\\d+\\.\\d+/.test(result));\r\n            }),\r\n            execAsync(\"node --non-existent-option\").catch(() => {\r\n                t.pass();\r\n            }),\r\n        ]);\r\n    }\r\n};",
    "static": true,
    "longname": "src/exec-async.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 29,
    "kind": "function",
    "name": "execAsync",
    "memberof": "src/exec-async.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/exec-async.js~execAsync",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/exec-async.js",
    "importStyle": null,
    "description": "Executes a system command and returns a promise for its stdout output.\nOutput to stderr is ignored.",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The command to execute"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "A promise for the output. Rejects if the command\nexits with nonzero code."
    }
  },
  {
    "__docId__": 30,
    "kind": "file",
    "name": "src/filter-in-place.js",
    "content": "/**\n * Filter an array in-place.\n * \n * @requires snippet:replace-array\n * \n * @param {function} filterFunction The filter function.\n * \n * @return {Array} Returns the same array.\n * \n * @example\n * \n * ```\n * let x = [1, -1, -2, 3];\n * filterInPlace(x, v => v > 0);\n * console.log(x); // [1, 3]\n * ```\n */\nconst filterInPlace = function(array, filterFunction) {\n    return snippets.replaceArray(array, array.filter(filterFunction));\n};\n\n/* test */ module.exports = {\n    snippet: filterInPlace,\n    snippetName: \"filterInPlace\",\n    snippetTest: t => {\n        const x = [1, -1, -2, 3];\n        filterInPlace(x, v => v > 0);\n        t.deepEqual(x, [1, 3]);\n    }\n};",
    "static": true,
    "longname": "src/filter-in-place.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 31,
    "kind": "function",
    "name": "filterInPlace",
    "memberof": "src/filter-in-place.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/filter-in-place.js~filterInPlace",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/filter-in-place.js",
    "importStyle": null,
    "description": "Filter an array in-place.",
    "examples": [
      "\n```\nlet x = [1, -1, -2, 3];\nfilterInPlace(x, v => v > 0);\nconsole.log(x); // [1, 3]\n```"
    ],
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "snippet:replace-array"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "filterFunction",
        "description": "The filter function."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "Returns the same array."
    }
  },
  {
    "__docId__": 32,
    "kind": "file",
    "name": "src/get-now-string.js",
    "content": "/**\n * Get a string representation of the current moment.\n * \n * The string follows the pattern of the following example: 2018-07-22_20h04min29s\n * \n * @return {string}\n */\nconst getNowString = function() {\n    const reg = /^(.+)T(.+):(.+):(.+)\\.\\d{3}Z$/;\n    const str = new Date().toJSON();\n    const res = reg.exec(str);\n    return res[1] + \"_\" + res[2] + \"h\" + res[3] + \"min\" + res[4] + \"s\";\n};\n\n/* test */ module.exports = {\n    snippet: getNowString,\n    snippetName: \"getNowString\",\n    snippetTest: t => {\n        t.regex(getNowString(), /^\\d{4}-\\d{2}-\\d{2}_\\d{2}h\\d{2}min\\d{2}s$/);\n    }\n};",
    "static": true,
    "longname": "src/get-now-string.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 33,
    "kind": "function",
    "name": "getNowString",
    "memberof": "src/get-now-string.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/get-now-string.js~getNowString",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/get-now-string.js",
    "importStyle": null,
    "description": "Get a string representation of the current moment.\n\nThe string follows the pattern of the following example: 2018-07-22_20h04min29s",
    "lineNumber": 8,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 34,
    "kind": "file",
    "name": "src/lorem-ipsum.js",
    "content": "/**\n * Generate a random string of words, lorem-ipsum style.\n * \n * @requires npm:lorem-ipsum^1.0.0\n * \n * @param {int} wordCount The amount of words to generate.\n * \n * @param {boolean} [fullstop=false] Whether or not to add a\n * full stop (\".\") in the end of the string.\n * \n * @param {boolean} [ucfirst=true] Whether or not the first\n * character is uppercase.\n * \n * @return {string} The generated string.\n */\nconst loremIpsum = (() => {\n    const loremIpsum = require('lorem-ipsum');\n    return function(wordCount, fullstop = false, ucfirst = true) {\n        let str = loremIpsum({ count: wordCount, units: 'words', format: 'plain' });\n        if (ucfirst) str = str[0].toUpperCase() + str.substr(1);\n        if (fullstop) str += \".\";\n        return str;\n    };\n})();\n\n/* test */ module.exports = {\n    snippet: loremIpsum,\n    snippetName: \"loremIpsum\",\n    snippetTest: t => {\n        t.pass();\n    }\n};",
    "static": true,
    "longname": "src/lorem-ipsum.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 35,
    "kind": "variable",
    "name": "loremIpsum",
    "memberof": "src/lorem-ipsum.js",
    "static": true,
    "longname": "src/lorem-ipsum.js~loremIpsum",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/lorem-ipsum.js",
    "importStyle": null,
    "description": "Generate a random string of words, lorem-ipsum style.",
    "lineNumber": 16,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "npm:lorem-ipsum^1.0.0"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "wordCount",
        "description": "The amount of words to generate."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "fullstop",
        "description": "Whether or not to add a\nfull stop (\".\") in the end of the string."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "ucfirst",
        "description": "Whether or not the first\ncharacter is uppercase."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated string."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 36,
    "kind": "file",
    "name": "src/make-private-accessor.js",
    "content": "/**\r\n * Generates an accessor function to get/set pseudo-private fields on objects. This function,\r\n * when passed an object, returns another object which is its pseudo-private field keeper. This\r\n * is better understood with an example.\r\n * \r\n * @returns {function}\r\n * \r\n * @example\r\n * \r\n * ```\r\n * const myObj = { publicField1: 1, publicField2: 2 };\r\n * const $ = makePrivateAccessor(); // Make a private accessor\r\n * $(myObj).privateField1 = 3;\r\n * console.log(myObj.privateField1); // undefined\r\n * console.log($(myObj).privateField1); // 3\r\n * const $2 = makePrivateAccessor(); // Another accessor\r\n * console.log($2(myObj).privateField1); // undefined\r\n * // Each accessor has their own 'private access' to the object\r\n * $2(myObj).privateField1 = 4;\r\n * console.log($2(myObj).privateField1); // 4\r\n * console.log($(myObj).privateField1); // 3\r\n * // If you lose access to the accessor function, you lose all\r\n * // the private properties set by it.\r\n * ```\r\n */\r\nconst makePrivateAccessor = function() {\r\n    const accessorWeakMap = new WeakMap();\r\n    return function accessor(obj) {\r\n        if (obj === null) throw new Error(\"Expected a non-null object, received null\");\r\n        if (typeof obj !== \"object\") throw new Error(`Expect a non-null object, received ${typeof obj}`);\r\n        if (!accessorWeakMap.has(obj)) {\r\n            const accessed = {};\r\n            accessorWeakMap.set(obj, accessed);\r\n            return accessed;\r\n        }\r\n        return accessorWeakMap.get(obj);\r\n    };\r\n};\r\n\r\n/* test */ module.exports = {\r\n    snippet: makePrivateAccessor,\r\n    snippetName: \"makePrivateAccessor\",\r\n    snippetTest: t => {\r\n        const myObj = { publicField1: 1, publicField2: 2 };\r\n        const $ = makePrivateAccessor();\r\n        $(myObj).privateField1 = 3;\r\n        t.is(myObj.privateField1, undefined);\r\n        t.is($(myObj).privateField1, 3);\r\n        const $2 = makePrivateAccessor();\r\n        t.is($2(myObj).privateField1, undefined);\r\n        $2(myObj).privateField1 = 4;\r\n        t.is($2(myObj).privateField1, 4);\r\n        t.is($(myObj).privateField1, 3);\r\n    }\r\n};",
    "static": true,
    "longname": "src/make-private-accessor.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 37,
    "kind": "function",
    "name": "makePrivateAccessor",
    "memberof": "src/make-private-accessor.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/make-private-accessor.js~makePrivateAccessor",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/make-private-accessor.js",
    "importStyle": null,
    "description": "Generates an accessor function to get/set pseudo-private fields on objects. This function,\nwhen passed an object, returns another object which is its pseudo-private field keeper. This\nis better understood with an example.",
    "examples": [
      "\n```\nconst myObj = { publicField1: 1, publicField2: 2 };\nconst $ = makePrivateAccessor(); // Make a private accessor\n$(myObj).privateField1 = 3;\nconsole.log(myObj.privateField1); // undefined\nconsole.log($(myObj).privateField1); // 3\nconst $2 = makePrivateAccessor(); // Another accessor\nconsole.log($2(myObj).privateField1); // undefined\n// Each accessor has their own 'private access' to the object\n$2(myObj).privateField1 = 4;\nconsole.log($2(myObj).privateField1); // 4\nconsole.log($(myObj).privateField1); // 3\n// If you lose access to the accessor function, you lose all\n// the private properties set by it.\n```"
    ],
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{function}"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 38,
    "kind": "file",
    "name": "src/map-in-place.js",
    "content": "/**\n * Map an array in-place.\n * \n * @requires snippet:replace-array\n * \n * @param {function} mapFunction The map function.\n * \n * @return {Array} Returns the same array.\n * \n * @example\n * \n * ```\n * let x = [1, -1, -2, 3];\n * mapInPlace(x, v => v + 2);\n * console.log(x); // [3, 1, 0, 5]\n * ```\n */\nconst mapInPlace = function(array, mapFunction) {\n    return snippets.replaceArray(array, array.map(mapFunction));\n};\n\n/* test */ module.exports = {\n    snippet: mapInPlace,\n    snippetName: \"mapInPlace\",\n    snippetTest: t => {\n        const x = [1, -1, -2, 3];\n        mapInPlace(x, v => v + 2);\n        t.deepEqual(x, [3, 1, 0, 5]);\n    }\n};",
    "static": true,
    "longname": "src/map-in-place.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 39,
    "kind": "function",
    "name": "mapInPlace",
    "memberof": "src/map-in-place.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/map-in-place.js~mapInPlace",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/map-in-place.js",
    "importStyle": null,
    "description": "Map an array in-place.",
    "examples": [
      "\n```\nlet x = [1, -1, -2, 3];\nmapInPlace(x, v => v + 2);\nconsole.log(x); // [3, 1, 0, 5]\n```"
    ],
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "snippet:replace-array"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "mapFunction",
        "description": "The map function."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "Returns the same array."
    }
  },
  {
    "__docId__": 40,
    "kind": "file",
    "name": "src/map-object.js",
    "content": "/**\n * Create a new object with the same keys as the given object, whose values\n * on those keys are mapped by the mapFunction function. This should be analogous\n * to the usage of Array.prototype.map, but for objects.\n * \n * @param {object} obj The source object\n * @param {function(value: *, key: string): *} mapFunction The map function\n * \n * @return {object} The new object\n * \n * @example\n * \n * ```\n * let x = { a: \"hello\", b: \"world\" };\n * let y = mapObject(x, (value, key) => value + \"-\" + key);\n * console.log(y); // { a: \"hello-a\", b: \"world-b\" };\n * ```\n */\nconst mapObject = function(obj, mapFunction) {\n    if (typeof obj !== \"object\") throw new TypeError(\"obj must be an object\");\n    if (typeof mapFunction !== \"function\") throw new TypeError(\"mapFunction must be a function\");\n    if (obj === null) return null;\n    const result = {};\n    Object.keys(obj).forEach(key => {\n        result[key] = mapFunction(obj[key], key);\n    });\n    return result;\n};\n\n/* test */ module.exports = {\n    snippet: mapObject,\n    snippetName: \"mapObject\",\n    snippetTest: t => {\n        const x = { a: \"hello\", b: \"world\" };\n        const y = mapObject(x, (value, key) => value + \"-\" + key);\n        t.deepEqual(y, { a: \"hello-a\", b: \"world-b\" });\n    }\n};",
    "static": true,
    "longname": "src/map-object.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 41,
    "kind": "function",
    "name": "mapObject",
    "memberof": "src/map-object.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/map-object.js~mapObject",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/map-object.js",
    "importStyle": null,
    "description": "Create a new object with the same keys as the given object, whose values\non those keys are mapped by the mapFunction function. This should be analogous\nto the usage of Array.prototype.map, but for objects.",
    "examples": [
      "\n```\nlet x = { a: \"hello\", b: \"world\" };\nlet y = mapObject(x, (value, key) => value + \"-\" + key);\nconsole.log(y); // { a: \"hello-a\", b: \"world-b\" };\n```"
    ],
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "The source object"
      },
      {
        "nullable": null,
        "types": [
          "function(value: *, key: string): *"
        ],
        "spread": false,
        "optional": false,
        "name": "mapFunction",
        "description": "The map function"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The new object"
    }
  },
  {
    "__docId__": 42,
    "kind": "file",
    "name": "src/node-secure-random.js",
    "content": "/**\r\n * Cryptographycally secure equivalent to Math.random() in Node.\r\n * \r\n * @return {number} A number between 0 (inclusive) and 1 (exclusive)\r\n */\r\nconst nodeSecureRandom = function() {\r\n    const crypto = require(\"crypto\");\r\n    return crypto.randomBytes(4).readUInt32BE(0) / 0x100000000;\r\n};\r\n\r\n/* test */ module.exports = {\r\n    snippet: nodeSecureRandom,\r\n    snippetName: \"nodeSecureRandom\",\r\n    snippetTest: t => {\r\n        for (let i = 0; i < 1000; i++) {\r\n            const r = nodeSecureRandom();\r\n            t.true(0 <= r && r < 1);\r\n        }\r\n    }\r\n};",
    "static": true,
    "longname": "src/node-secure-random.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 43,
    "kind": "function",
    "name": "nodeSecureRandom",
    "memberof": "src/node-secure-random.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/node-secure-random.js~nodeSecureRandom",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/node-secure-random.js",
    "importStyle": null,
    "description": "Cryptographycally secure equivalent to Math.random() in Node.",
    "lineNumber": 6,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "A number between 0 (inclusive) and 1 (exclusive)"
    }
  },
  {
    "__docId__": 44,
    "kind": "file",
    "name": "src/open-native-file-select-dialog.js",
    "content": "/**\n * Open the native file select dialog, exaclty as\n * when a user clicks on a <input type='file' />.\n * \n * @return {Promise} A promise that resolves with the\n * selected file(s).\n */\nconst openNativeFileSelectDialog = function() {\n    return new Promise(resolve => {\n        const input = document.createElement(\"input\"); /* global document */\n        input.type = \"file\";\n        input.style.display = \"none\";\n        input.onchange = function(e) {\n            resolve(e.target.files);\n        };\n        input.click();\n        input.remove();\n    });\n};\n\n/* test */ module.exports = {\n    snippet: openNativeFileSelectDialog,\n    snippetName: \"openNativeFileSelectDialog\",\n    snippetTest: t => {\n        t.pass();\n    }\n};",
    "static": true,
    "longname": "src/open-native-file-select-dialog.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 45,
    "kind": "function",
    "name": "openNativeFileSelectDialog",
    "memberof": "src/open-native-file-select-dialog.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/open-native-file-select-dialog.js~openNativeFileSelectDialog",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/open-native-file-select-dialog.js",
    "importStyle": null,
    "description": "Open the native file select dialog, exaclty as\nwhen a user clicks on a <input type='file' />.",
    "lineNumber": 8,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise that resolves with the\nselected file(s)."
    }
  },
  {
    "__docId__": 46,
    "kind": "file",
    "name": "src/overlays.js",
    "content": "/**\r\n * A collection of methods to work with overlays.\r\n * \r\n * @property {function(element: HTMLElement, options: object): HTMLDivElement} createFor (see the code inside for documentation)\r\n * @property {object} createFor.defaultOptions (see the code inside for documentation)\r\n * @property {function(element: HTMLElement): number} removeAllFor (see the code inside for documentation)\r\n */\r\nconst overlays = (() => {\r\n\r\n    /* global document, window */\r\n\r\n    const overlays = {};\r\n\r\n    const overlayMap = new WeakMap();\r\n\r\n    function registerOverlay(element, overlay) {\r\n        if (!overlayMap.has(element)) {\r\n            overlayMap.set(element, new Set([overlay]));\r\n        } else {\r\n            overlayMap.get(element).add(overlay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create an overlay div covering the given element and returns it, so you can add styles or\r\n     * do something else. Automatically detects the given element's z-index and copies it, to ensure\r\n     * that the overlay gets above the element.\r\n     * \r\n     * @param {HTMLElement | string} element The element, or a query selector for it.\r\n     * @param {object} [options] An object with options. See `overlays.createFor.defaultOptions` to learn more.\r\n     * \r\n     * @return {HTMLDivElement} The created overlay\r\n     */\r\n    overlays.createFor = function(element, options) {\r\n        options = Object.assign({}, options || {}, overlays.createFor.defaultOptions);\r\n        if (typeof element === \"string\") element = document.querySelector(element);\r\n        const rect = element.getBoundingClientRect();\r\n        const overlay = document.createElement(\"div\");\r\n        overlay.style.width = (rect.right - rect.left) + \"px\";\r\n        overlay.style.height = (rect.bottom - rect.top) + \"px\";\r\n        overlay.style.position = \"absolute\";\r\n        overlay.style.top = rect.top + \"px\";\r\n        overlay.style.left = rect.left + \"px\";\r\n        overlay.style.zIndex = window.getComputedStyle(element).zIndex;\r\n        overlay.className = options.classNames;\r\n        document.documentElement.appendChild(overlay);\r\n        registerOverlay(element, overlay);\r\n        return overlay;\r\n    };\r\n\r\n    /**\r\n     * The default options to be used by `overlays.createFor`.\r\n     * \r\n     * @type {object}\r\n     * \r\n     * @property {string | Array<string>} classNames CSS classes to apply on the element. This can be an array of class names or a string of space-separated class names.\r\n     */\r\n    overlays.createFor.defaultOptions = {\r\n        classNames: \"overlay\"\r\n    };\r\n\r\n    /**\r\n     * Remove all overlays present in the given element.\r\n     * \r\n     * @param {HTMLElement | string} element The element, or a query selector for it.\r\n     * \r\n     * @return {number} The amount of removed overlays\r\n     */\r\n    overlays.removeAllFor = function(element) {\r\n        if (typeof element === \"string\") element = document.querySelector(element);\r\n        if (!overlayMap.has(element)) return 0;\r\n        const amount = overlayMap.get(element).size;\r\n        for (const overlay of overlayMap.get(element)) {\r\n            overlay.remove();\r\n        }\r\n        return amount;\r\n    };\r\n\r\n    return overlays;\r\n\r\n})();\r\n\r\n/* test */ module.exports = {\r\n    snippet: overlays,\r\n    snippetName: \"overlays\",\r\n    snippetTest: t => {\r\n        t.pass();\r\n    }\r\n};",
    "static": true,
    "longname": "src/overlays.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 47,
    "kind": "variable",
    "name": "overlays",
    "memberof": "src/overlays.js",
    "static": true,
    "longname": "src/overlays.js~overlays",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/overlays.js",
    "importStyle": null,
    "description": "A collection of methods to work with overlays.",
    "lineNumber": 8,
    "properties": [
      {
        "nullable": null,
        "types": [
          "function(element: HTMLElement, options: object): HTMLDivElement"
        ],
        "spread": false,
        "optional": false,
        "name": "createFor",
        "description": "(see the code inside for documentation)"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "createFor.defaultOptions",
        "description": "(see the code inside for documentation)"
      },
      {
        "nullable": null,
        "types": [
          "function(element: HTMLElement): number"
        ],
        "spread": false,
        "optional": false,
        "name": "removeAllFor",
        "description": "(see the code inside for documentation)"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/pick-random-subset.js",
    "content": "/**\n * Pick a random subset array of the given array.\n * \n * @requires snippet:random-int\n * \n * @param {Array} array The source array.\n * \n * @param {object} [options] An object specifying options.\n * @param {int} [options.length] If specified, defines the length of the subset to be taken.\n * If omitted (undefined), the length of the subset will be defined randomly between\n * options.minLength and array.length (inclusive)\n * @param {int} [options.minLength=0] This option is only relevant if options.length is\n * undefined. This option defines the minimum length of the picked subset. A common use case\n * is to set this option to 1 instead of the default 0 to disallow the empty subset to be\n * taken.\n * \n * @returns {Array} An array whose elements consist of a random subset of the given array.\n * \n * @throws {Error} If options.length or options.minLength is greater than array.length.\n */\nconst pickRandomSubset = function(array, options = undefined) {\n    // Edited from https://github.com/Jam3/random-array-subset\n\n    let length = options && options.length !== undefined ? options.length : undefined;\n    const minLength = options && options.minLength !== undefined ? options.minLength : 0;\n\n    if (length === undefined) {\n        if (minLength > array.length) {\n            throw new Error(\"The specified minLength can't be greater than the array length.\");\n        }\n        length = snippets.randomInt(minLength, array.length + 1);\n    } else if (length > array.length) {\n        throw new Error(\"The specified length can't be greater than the array length.\");\n    }\n    array = array.slice();\n    const result = [];\n    while (result.length < length) {\n        const index = snippets.randomInt(0, array.length);\n        result.push(array[index]);\n        array.splice(index, 1);\n    }\n    return result;\n};\n\n/* test */ module.exports = {\n    snippet: pickRandomSubset,\n    snippetName: \"pickRandomSubset\",\n    snippetTest: t => {\n        const array = [{}, {}, {}, {}];\n        for (let i = 0; i < 20; i++) {\n            t.true(snippets.arrayHas(array, ...pickRandomSubset(array)));\n            t.is(pickRandomSubset(array, { length: 3 }).length, 3);\n            t.is(pickRandomSubset(array, { length: 0 }).length, 0);\n            t.true(pickRandomSubset(array, { minLength: 1 }).length > 0);\n        }\n    }\n};",
    "static": true,
    "longname": "src/pick-random-subset.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "function",
    "name": "pickRandomSubset",
    "memberof": "src/pick-random-subset.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/pick-random-subset.js~pickRandomSubset",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/pick-random-subset.js",
    "importStyle": null,
    "description": "Pick a random subset array of the given array.",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "snippet:random-int"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Array} An array whose elements consist of a random subset of the given array."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "The source array."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "An object specifying options."
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": true,
        "name": "options.length",
        "description": "If specified, defines the length of the subset to be taken.\nIf omitted (undefined), the length of the subset will be defined randomly between\noptions.minLength and array.length (inclusive)"
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "options.minLength",
        "description": "This option is only relevant if options.length is\nundefined. This option defines the minimum length of the picked subset. A common use case\nis to set this option to 1 instead of the default 0 to disallow the empty subset to be\ntaken."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "An array whose elements consist of a random subset of the given array."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If options.length or options.minLength is greater than array.length."
      }
    ]
  },
  {
    "__docId__": 50,
    "kind": "file",
    "name": "src/pick-random.js",
    "content": "/**\n * Pick a random element from the given array (using a uniform distribution\n * produced by `Math.random()`).\n * \n * @param {Array} array The array.\n * \n * @returns {*} A random element from the given array.\n *\n */\nconst pickRandom = function(array) {\n    return array[Math.floor(Math.random() * array.length)];\n};\n\n/* test */ module.exports = {\n    snippet: pickRandom,\n    snippetName: \"pickRandom\",\n    snippetTest: t => {\n        const array = [{}, {}, {}, {}];\n        for (let i = 0; i < 10; i++) {\n            t.true(snippets.arrayHas(array, pickRandom(array)));\n        }\n    }\n};",
    "static": true,
    "longname": "src/pick-random.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 51,
    "kind": "function",
    "name": "pickRandom",
    "memberof": "src/pick-random.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/pick-random.js~pickRandom",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/pick-random.js",
    "importStyle": null,
    "description": "Pick a random element from the given array (using a uniform distribution\nproduced by `Math.random()`).",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*} A random element from the given array."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "The array."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "A random element from the given array."
    }
  },
  {
    "__docId__": 52,
    "kind": "file",
    "name": "src/random-int.js",
    "content": "/**\n * Generates an int between begin (inclusive) and end (exclusive).\n * \n * @param {int} begin The begin of the range (inclusive)\n * @param {int} end The end of the range (exclusive)\n * @return {int} An int whose value is between begin (inclusive) and\n * end (exclusive).\n * \n * @throws {Error} If end <= begin.\n * \n * @example\n * \n * ```\n * randomInt(0, 5); // A value between 0 and 4 (inclusive)\n * randomInt(-3, 1); // A value between -3 and 0 (inclusive)\n * ```\n */\nconst randomInt = function(begin, end) {\n    if (end <= begin) throw new Error(\"end must be greater than begin\");\n    return Math.floor(Math.random() * (end - begin)) + begin;\n};\n\n/* test */ module.exports = {\n    snippet: randomInt,\n    snippetName: \"randomInt\",\n    snippetTest: t => {\n        for (let i = 0; i < 100; i++) {\n            const random = randomInt(-3, 1);\n            t.true(-3 <= random);\n            t.true(random < 1);\n        }\n    }\n};",
    "static": true,
    "longname": "src/random-int.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 53,
    "kind": "function",
    "name": "randomInt",
    "memberof": "src/random-int.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/random-int.js~randomInt",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/random-int.js",
    "importStyle": null,
    "description": "Generates an int between begin (inclusive) and end (exclusive).",
    "examples": [
      "\n```\nrandomInt(0, 5); // A value between 0 and 4 (inclusive)\nrandomInt(-3, 1); // A value between -3 and 0 (inclusive)\n```"
    ],
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "begin",
        "description": "The begin of the range (inclusive)"
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": "The end of the range (exclusive)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "int"
      ],
      "spread": false,
      "description": "An int whose value is between begin (inclusive) and\nend (exclusive)."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If end <= begin."
      }
    ]
  },
  {
    "__docId__": 54,
    "kind": "file",
    "name": "src/read-console.js",
    "content": "/**\r\n * Reads user input from the console, optionally typing a message first.\r\n * \r\n * @param {string} [message] An optional message to prompt the user\r\n * \r\n * @return {Promise<string>} A promise with the typed answer\r\n */\r\nconst readConsole = function(message) {\r\n    message = message ? \"\" + message : \"\";\r\n    const readline = require(\"readline\");\r\n    return new Promise(resolve => {\r\n        const readlineInterface = readline.createInterface({\r\n            input: process.stdin,\r\n            output: process.stdout\r\n        });\r\n        readlineInterface.question(message, answer => {\r\n            readlineInterface.close();\r\n            resolve(answer);\r\n        });\r\n    });\r\n};\r\n\r\n/* test */ module.exports = {\r\n    snippet: readConsole,\r\n    snippetName: \"readConsole\",\r\n    snippetTest: t => {\r\n        t.pass();\r\n    }\r\n};",
    "static": true,
    "longname": "src/read-console.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 55,
    "kind": "function",
    "name": "readConsole",
    "memberof": "src/read-console.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/read-console.js~readConsole",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/read-console.js",
    "importStyle": null,
    "description": "Reads user input from the console, optionally typing a message first.",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "message",
        "description": "An optional message to prompt the user"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "A promise with the typed answer"
    }
  },
  {
    "__docId__": 56,
    "kind": "file",
    "name": "src/replace-array.js",
    "content": "/**\n * Replaces an array with another array (in-place).\n * \n * @param {array} baseArray The array that will be replaced by the other array.\n * @param {array} otherArray The array whose values will be put into the base array.\n * This array is not modified by calling this function.\n * \n * @return {array} Returns the base array (for chaining convenience).\n * \n * @example\n * \n * ```\n * let x = [1, -1, -2, 3];\n * replaceArray(x, [\"a\", \"b\"]);\n * console.log(x); // [\"a\", \"b\"]\n * ```\n */\nconst replaceArray = function(baseArray, otherArray) {\n    baseArray.splice(0, baseArray.length, ...otherArray);\n    return baseArray;\n};\n\n/* test */ module.exports = {\n    snippet: replaceArray,\n    snippetName: \"replaceArray\",\n    snippetTest: t => {\n        const x = [1, -1, -2, 3];\n        replaceArray(x, [\"a\", \"b\"]);\n        t.deepEqual(x, [\"a\", \"b\"]);\n    }\n};",
    "static": true,
    "longname": "src/replace-array.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 57,
    "kind": "function",
    "name": "replaceArray",
    "memberof": "src/replace-array.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/replace-array.js~replaceArray",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/replace-array.js",
    "importStyle": null,
    "description": "Replaces an array with another array (in-place).",
    "examples": [
      "\n```\nlet x = [1, -1, -2, 3];\nreplaceArray(x, [\"a\", \"b\"]);\nconsole.log(x); // [\"a\", \"b\"]\n```"
    ],
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "baseArray",
        "description": "The array that will be replaced by the other array."
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "otherArray",
        "description": "The array whose values will be put into the base array.\nThis array is not modified by calling this function."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "Returns the base array (for chaining convenience)."
    }
  },
  {
    "__docId__": 58,
    "kind": "file",
    "name": "src/sanitize-html-in-text.js",
    "content": "/**\n * Replaces all occurrences of '&', '<', '>', '\"' and \"'\" in text\n * with their 'safe' counterparts (such as '&amp;').\n * \n * @param {string} text The text to be sanitized\n * \n * @return {string} The sanitized text\n */\nconst sanitizeHTMLInText = function(text) {\n    const map = { '&': 'amp', '<': 'lt', '>': 'gt', '\"': 'quot', \"'\": '#039' };\n    return text.replace(/[&<>\"']/g, m => `&${map[m]};`);\n};\n\n/* test */ module.exports = {\n    snippet: sanitizeHTMLInText,\n    snippetName: \"sanitizeHTMLInText\",\n    snippetTest: t => {\n        t.is(sanitizeHTMLInText(`&<>\"'`), \"&amp;&lt;&gt;&quot;&#039;\");\n    }\n};",
    "static": true,
    "longname": "src/sanitize-html-in-text.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 59,
    "kind": "function",
    "name": "sanitizeHTMLInText",
    "memberof": "src/sanitize-html-in-text.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/sanitize-html-in-text.js~sanitizeHTMLInText",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/sanitize-html-in-text.js",
    "importStyle": null,
    "description": "Replaces all occurrences of '&', '<', '>', '\"' and \"'\" in text\nwith their 'safe' counterparts (such as '&amp;').",
    "lineNumber": 9,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "The text to be sanitized"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The sanitized text"
    }
  },
  {
    "__docId__": 60,
    "kind": "file",
    "name": "src/sha-256.js",
    "content": "/**\n * Generates the SHA-256 hash of the given string.\n * \n * (c) Chris Veness 2002-2014 / MIT License\n * Modified by Pedro Augusto de Paula Barbosa (2018) - MIT\n * \n * See http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html\n * and http://csrc.nist.gov/groups/ST/toolkit/examples.html\n * \n * @requires npm:utf8\n * \n * @param {string} str The string to be hashed\n * @return {string} The hash of the string, which is a string of\n * length 64 and made of only hexadecimal symbols (0-9 and a-f).\n * \n * @example\n * \n * ```\n * sha256(\"test\"); // \"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\"\n * ```\n */\nconst sha256 = (function() {\n\n    const utf8 = require('utf8');\n\n    const priv = {};\n\n    /**\n     * Rotates right (circular right shift) value x by n positions [§3.2.4].\n     */\n    priv.ROTR = function(n, x) {\n        return (x >>> n) | (x << (32-n));\n    };\n\n    /**\n     * Logical functions [§4.1.2].\n     */\n    priv.Sigma0 = function(x) { return priv.ROTR(2,  x) ^ priv.ROTR(13, x) ^ priv.ROTR(22, x); };\n    priv.Sigma1 = function(x) { return priv.ROTR(6,  x) ^ priv.ROTR(11, x) ^ priv.ROTR(25, x); };\n    priv.sigma0 = function(x) { return priv.ROTR(7,  x) ^ priv.ROTR(18, x) ^ (x>>>3); };\n    priv.sigma1 = function(x) { return priv.ROTR(17, x) ^ priv.ROTR(19, x) ^ (x>>>10); };\n    priv.Ch = function(x, y, z) { return (x & y) ^ (~x & z); };\n    priv.Maj = function(x, y, z) { return (x & y) ^ (x & z) ^ (y & z); };\n\n    /**\n     * Hexadecimal representation of a number.\n     */\n    priv.toHexStr = function(n) {\n        // Note that we can't use toString(16) as it is implementation-dependant,\n        // and in IE it returns signed numbers when used on full words.\n        let s = \"\", v;\n        for (let i = 7; i >= 0; i--) { v = (n>>>(i*4)) & 0xf; s += v.toString(16); }\n        return s;\n    };\n\n    return function sha256(str) {\n        if (typeof str !== \"string\") {\n            throw new TypeError(\"sha256: Parameter must be a string.\");\n        }\n\n        // convert string to UTF-8, as SHA only deals with byte-streams\n        let msg = utf8.encode(str);\n        \n        // constants [§4.2.2]\n        const K = [\n            0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n            0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n            0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n            0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n            0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n            0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n            0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n            0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n        ];\n\n        // initial hash value [§5.3.1]\n        const H = [\n            0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n        ];\n\n        // PREPROCESSING\n    \n        msg += String.fromCharCode(0x80); // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n        // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n        const l = msg.length/4 + 2; // length (in 32-bit integers) of msg + ‘1’ + appended length\n        const N = Math.ceil(l/16); // number of 16-integer-blocks required to hold 'l' ints\n        const M = new Array(N);\n\n        for (let i=0; i<N; i++) {\n            M[i] = new Array(16);\n            for (let j=0; j<16; j++) { // encode 4 chars per integer, big-endian encoding\n                M[i][j] = (msg.charCodeAt(i*64+j*4)<<24) | (msg.charCodeAt(i*64+j*4+1)<<16) |\n                          (msg.charCodeAt(i*64+j*4+2)<<8) | (msg.charCodeAt(i*64+j*4+3));\n            } // note running off the end of msg is ok since bitwise ops on NaN return 0\n        }\n        // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n        // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n        // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n        M[N-1][14] = ((msg.length-1)*8) / Math.pow(2, 32); M[N-1][14] = Math.floor(M[N-1][14]);\n        M[N-1][15] = ((msg.length-1)*8) & 0xffffffff;\n\n        // HASH COMPUTATION [§6.1.2]\n\n        const W = new Array(64); let a, b, c, d, e, f, g, h;\n        for (let i=0; i<N; i++) {\n\n            // 1 - prepare message schedule 'W'\n            for (let t=0;  t<16; t++) W[t] = M[i][t];\n            for (let t=16; t<64; t++) W[t] = (priv.sigma1(W[t-2]) + W[t-7] + priv.sigma0(W[t-15]) + W[t-16]) & 0xffffffff;\n\n            // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n            a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n            // 3 - main loop (note 'addition modulo 2^32')\n            for (let t=0; t<64; t++) {\n                const T1 = h + priv.Sigma1(e) + priv.Ch(e, f, g) + K[t] + W[t];\n                const T2 = priv.Sigma0(a) + priv.Maj(a, b, c);\n                h = g;\n                g = f;\n                f = e;\n                e = (d + T1) & 0xffffffff;\n                d = c;\n                c = b;\n                b = a;\n                a = (T1 + T2) & 0xffffffff;\n            }\n\n            // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n            H[0] = (H[0]+a) & 0xffffffff;\n            H[1] = (H[1]+b) & 0xffffffff;\n            H[2] = (H[2]+c) & 0xffffffff;\n            H[3] = (H[3]+d) & 0xffffffff;\n            H[4] = (H[4]+e) & 0xffffffff;\n            H[5] = (H[5]+f) & 0xffffffff;\n            H[6] = (H[6]+g) & 0xffffffff;\n            H[7] = (H[7]+h) & 0xffffffff;\n        }\n\n        return priv.toHexStr(H[0]) + priv.toHexStr(H[1]) + priv.toHexStr(H[2]) + priv.toHexStr(H[3]) +\n               priv.toHexStr(H[4]) + priv.toHexStr(H[5]) + priv.toHexStr(H[6]) + priv.toHexStr(H[7]);\n    };\n\n})();\n\n/* test */ module.exports = {\n    snippet: sha256,\n    snippetName: \"sha256\",\n    snippetTest: t => {\n        t.is(sha256(\"test\"), \"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\");\n        t.is(sha256(\"中文\"), \"72726d8818f693066ceb69afa364218b692e62ea92b385782363780f47529c21\");\n    }\n};",
    "static": true,
    "longname": "src/sha-256.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 61,
    "kind": "variable",
    "name": "sha256",
    "memberof": "src/sha-256.js",
    "static": true,
    "longname": "src/sha-256.js~sha256",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/sha-256.js",
    "importStyle": null,
    "description": "Generates the SHA-256 hash of the given string.\n\n(c) Chris Veness 2002-2014 / MIT License\nModified by Pedro Augusto de Paula Barbosa (2018) - MIT\n\nSee http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html\nand http://csrc.nist.gov/groups/ST/toolkit/examples.html",
    "examples": [
      "\n```\nsha256(\"test\"); // \"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\"\n```"
    ],
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "npm:utf8"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "The string to be hashed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The hash of the string, which is a string of\nlength 64 and made of only hexadecimal symbols (0-9 and a-f)."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "file",
    "name": "src/shallow-clone.js",
    "content": "/**\n * Returns a shallow clone of the given object.\n * \n * @param {object} obj The object to be shallow-cloned\n * @return {object} The shallow-cloned object\n */\nconst shallowClone = function(obj) {\n    return Object.assign({}, obj);\n};\n\n/* test */ module.exports = {\n    snippet: shallowClone,\n    snippetName: \"shallowClone\",\n    snippetTest: t => {\n        const x = { a: 1, b: 2 };\n        t.not(x, { a: 1, b: 2 });\n        t.deepEqual(shallowClone(x), { a: 1, b: 2 });\n    }\n};",
    "static": true,
    "longname": "src/shallow-clone.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 63,
    "kind": "function",
    "name": "shallowClone",
    "memberof": "src/shallow-clone.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/shallow-clone.js~shallowClone",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/shallow-clone.js",
    "importStyle": null,
    "description": "Returns a shallow clone of the given object.",
    "lineNumber": 7,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "The object to be shallow-cloned"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The shallow-cloned object"
    }
  },
  {
    "__docId__": 64,
    "kind": "file",
    "name": "src/shuffle-array.js",
    "content": "/**\n * Shuffles the given array in-place, using the Fisher-Yates algorithm (also known\n * as Knuth algorithm).\n * \n * Recall that if you want a new array instead of changing the existing array, just\n * call .slice() before.\n * \n * @param {Array} array The array to be shuffled.\n * @return {Array} The same array (for chaining convenience).\n * \n * @example\n * \n * ```\n * let fruits = [\"Apple\", \"Orange\", \"Mango\"];\n * fruits.shuffle();\n * console.log(fruits); // [\"Orange\", \"Mango\", \"Apple\"];\n * ```\n * \n * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n * Credits to http://sedition.com/perl/javascript-fy.html\n * Thanks also to CoolAJ86\n */\nconst shuffleArray = function(array) {\n    if (!Array.isArray(array)) {\n        throw new TypeError(\"Parameter must be an array.\");\n    }\n\n    let currentIndex = array.length;\n    let randomIndex;\n    let temp;\n\n    // While there remain elements to shuffle...\n    while (currentIndex > 0) {\n\n        // Pick a remaining element...\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n\n        // And swap it with the current element.\n        temp = array[currentIndex];\n        array[currentIndex] = array[randomIndex];\n        array[randomIndex] = temp;\n    }\n\n    return array;\n};\n\n/* test */ module.exports = {\n    snippet: shuffleArray,\n    snippetName: \"shuffleArray\",\n    snippetTest: t => {\n        const fruits = [\"Apple\", \"Orange\", \"Mango\"];\n        const result = shuffleArray(fruits);\n        t.is(fruits, result);\n        t.true(snippets.arrayHas(result, \"Apple\", \"Orange\", \"Mango\"));\n\n        t.throws(() => shuffleArray({}));\n        t.throws(() => shuffleArray(null));\n        t.throws(() => shuffleArray(5));\n        t.throws(() => shuffleArray(\"test\"));\n    }\n};",
    "static": true,
    "longname": "src/shuffle-array.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 65,
    "kind": "function",
    "name": "shuffleArray",
    "memberof": "src/shuffle-array.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/shuffle-array.js~shuffleArray",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/shuffle-array.js",
    "importStyle": null,
    "description": "Shuffles the given array in-place, using the Fisher-Yates algorithm (also known\nas Knuth algorithm).\n\nRecall that if you want a new array instead of changing the existing array, just\ncall .slice() before.",
    "examples": [
      "\n```\nlet fruits = [\"Apple\", \"Orange\", \"Mango\"];\nfruits.shuffle();\nconsole.log(fruits); // [\"Orange\", \"Mango\", \"Apple\"];\n```\n\nhttp://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\nCredits to http://sedition.com/perl/javascript-fy.html\nThanks also to CoolAJ86"
    ],
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "The array to be shuffled."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "The same array (for chaining convenience)."
    }
  },
  {
    "__docId__": 66,
    "kind": "file",
    "name": "src/simple-substitution-cipher.js",
    "content": "/**\n * Perform a simple substitution cipher on a string. Note: this is a very weak encryption algorithm that shouldn't\n * be used for security purposes.\n * \n * It is common to associate this function with Base64 encode/decode methods so that any string can be encrypted,\n * instead of only working with strings whose chars are in the plaintext alphabet. The default plaintext and\n * ciphertext alphabets are compatible with Base64. See, for example. js-base64 by dankogai on npm.\n *\n * @param {string} str The string to be encrypted.\n * \n * @param {Object} [options] An object to provide options.\n * \n * @param {string} [options.plaintextAlphabet=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"]\n * The plaintext alphabet to be used. Must have the same length as options.ciphertextAlphabet.\n * \n * @param {string} [options.ciphertextAlphabet=\"hrVtM=TYziLNIemw39dBXDj18lykGUPosR20+fEK6buFCcJpZgqWH/xQ57S4nvaAO\"]\n * The ciphertext alphabet to be used. Must have the same length as options.plaintextAlphabet.\n * \n * @param {boolean} [options.reverse=false] Whether or not to reverse the encryption. Setting this to true is exactly\n * equivalent as switching options.plaintextAlphabet and options.ciphertextAlphabet.\n * \n * @param {char | null} [options.unknownChar=\"?\"] The character to be used in place of a character in the input string that\n * is not present in the plaintext alphabet. If null, the character will be left untouched.\n * \n * @see https://en.wikipedia.org/wiki/Substitution_cipher\n * \n * @example\n * \n * ```\n * simpleSubstitutionCipher(\"Hello\"); //\"YPff6\"\n * simpleSubstitutionCipher(\"YPff6\", { reverse: true }); // \"Hello\"\n * simpleSubstitutionCipher(\"Hello\", {\n *     ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\"\n * }); // \"WDpp=\"\n * simpleSubstitutionCipher(\"WDpp=\", {\n *     ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\",\n *     reverse: true\n * }); // \"Hello\"\n * ```\n */\nconst simpleSubstitutionCipher = function(str, options = {}) {\n    let plaintextAlphabet = options.plaintextAlphabet;\n    let ciphertextAlphabet = options.ciphertextAlphabet;\n    let reverse = options.reverse;\n    let unknownChar = options.unknownChar;\n\n    if (plaintextAlphabet === undefined) plaintextAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    if (ciphertextAlphabet === undefined) ciphertextAlphabet = \"hrVtM=TYziLNIemw39dBXDj18lykGUPosR20+fEK6buFCcJpZgqWH/xQ57S4nvaAO\";\n    if (reverse === undefined) reverse = false;\n    if (unknownChar === undefined) unknownChar = \"?\";\n\n    if (typeof plaintextAlphabet !== \"string\") throw new Error(\"Plaintext alphabet must be a string.\");\n    if (typeof ciphertextAlphabet !== \"string\") throw new Error(\"Ciphertext alphabet must be a string.\");\n\n    if (plaintextAlphabet.length !== ciphertextAlphabet.length) {\n        throw new Error(\"Plaintext alphabet and ciphertext alphabet must have the same length.\");\n    }\n\n    if (reverse) {\n        const temp = plaintextAlphabet;\n        plaintextAlphabet = ciphertextAlphabet;\n        ciphertextAlphabet = temp;\n    }\n\n    const lookupMap = new Map();\n    for (let i = 0; i < plaintextAlphabet.length; i++) {\n        lookupMap.set(plaintextAlphabet.charAt(i), ciphertextAlphabet.charAt(i));\n    }\n\n    const result = [];\n    for (let i = 0; i < str.length; i++) {\n        let char = lookupMap.get(str.charAt(i));\n        if (char === undefined) char = unknownChar === null ? char : unknownChar;\n        result.push(char);\n    }\n\n    return result.join(\"\");\n};\n\n/* test */ module.exports = {\n    snippet: simpleSubstitutionCipher,\n    snippetName: \"simpleSubstitutionCipher\",\n    snippetTest: t => {\n        t.is(simpleSubstitutionCipher(\"Hello\"), \"YPff6\");\n        t.is(simpleSubstitutionCipher(\"YPff6\", { reverse: true }), \"Hello\");\n        t.is(simpleSubstitutionCipher(\"Hello\", {\n            ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\"\n        }), \"WDpp=\");\n        t.is(simpleSubstitutionCipher(\"WDpp=\", {\n            ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\",\n            reverse: true\n        }), \"Hello\");\n    }\n};\n\n\n\n\n\n// t.is(simpleSubstitutionCipher(\"hello! ^^\"), \"yTDCkTnRz=7P\");\n// t.is(simpleSubstitutionCipher(\"yTDCkTnRz=7P\", { reverse: true }), \"hello! ^^\");\n// t.is(simpleSubstitutionCipher(\"hello! ^^\", {\n//     ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\"\n// }), \"lf1HPfXTQthD\");\n// t.is(simpleSubstitutionCipher(\"lf1HPfXTQthD\", {\n//     ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\",\n//     reverse: true\n// }), \"hello! ^^\");",
    "static": true,
    "longname": "src/simple-substitution-cipher.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 67,
    "kind": "function",
    "name": "simpleSubstitutionCipher",
    "memberof": "src/simple-substitution-cipher.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/simple-substitution-cipher.js~simpleSubstitutionCipher",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/simple-substitution-cipher.js",
    "importStyle": null,
    "description": "Perform a simple substitution cipher on a string. Note: this is a very weak encryption algorithm that shouldn't\nbe used for security purposes.\n\nIt is common to associate this function with Base64 encode/decode methods so that any string can be encrypted,\ninstead of only working with strings whose chars are in the plaintext alphabet. The default plaintext and\nciphertext alphabets are compatible with Base64. See, for example. js-base64 by dankogai on npm.",
    "examples": [
      "\n```\nsimpleSubstitutionCipher(\"Hello\"); //\"YPff6\"\nsimpleSubstitutionCipher(\"YPff6\", { reverse: true }); // \"Hello\"\nsimpleSubstitutionCipher(\"Hello\", {\n    ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\"\n}); // \"WDpp=\"\nsimpleSubstitutionCipher(\"WDpp=\", {\n    ciphertextAlphabet: \"cq/r8tfWQ306yFAEVK24O1jGIolPMnD7gTUZdpCm=+kxHzSNLs59iuBbahevXJwYR\",\n    reverse: true\n}); // \"Hello\"\n```"
    ],
    "see": [
      "https://en.wikipedia.org/wiki/Substitution_cipher"
    ],
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "The string to be encrypted."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "An object to provide options."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.plaintextAlphabet",
        "description": "The plaintext alphabet to be used. Must have the same length as options.ciphertextAlphabet."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.ciphertextAlphabet",
        "description": "The ciphertext alphabet to be used. Must have the same length as options.plaintextAlphabet."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.reverse",
        "description": "Whether or not to reverse the encryption. Setting this to true is exactly\nequivalent as switching options.plaintextAlphabet and options.ciphertextAlphabet."
      },
      {
        "nullable": null,
        "types": [
          "char ",
          " null"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"?\"",
        "defaultRaw": "?",
        "name": "options.unknownChar",
        "description": "The character to be used in place of a character in the input string that\nis not present in the plaintext alphabet. If null, the character will be left untouched."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "src/sort-by.js",
    "content": "/**\n * Sort the given array in-place using the values returned by the valuePicker.\n * \n * @requires snippet:map-in-place\n * \n * @param {Array} array The array to be sorted.\n * @param {function} valuePicker A function that when applied to each value of\n * the array returns another value to be used for the sorting. This function is\n * called only once per value.\n * @param {boolean} [reverse=false] Whether or not to reverse the sorting.\n * \n * @return {Array} The given array (for chaining convenience).\n * \n * @example\n * \n * ```\n * let list = [{id:7},{id:3}];\n * sortBy(list, x => x.id);\n * console.log(x); // [{id:3},{id:7}];\n * ```\n */\nconst sortBy = function(array, valuePicker, reverse = false) {\n    const n = reverse ? -1 : 1;\n    snippets.mapInPlace(array, x => ({ value: x, picked: valuePicker(x) }));\n    array.sort((a, b) => a.picked < b.picked ? -n : a.picked === b.picked ? 0 : n);\n    snippets.mapInPlace(array, x => x.value);\n    return array;\n};\n\n/* test */ module.exports = {\n    snippet: sortBy,\n    snippetName: \"sortBy\",\n    snippetTest: t => {\n        const list = [{id:7},{id:3}];\n        sortBy(list, x => x.id);\n        t.deepEqual(list, [{id:3},{id:7}]);\n    }\n};",
    "static": true,
    "longname": "src/sort-by.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "function",
    "name": "sortBy",
    "memberof": "src/sort-by.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/sort-by.js~sortBy",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/sort-by.js",
    "importStyle": null,
    "description": "Sort the given array in-place using the values returned by the valuePicker.",
    "examples": [
      "\n```\nlet list = [{id:7},{id:3}];\nsortBy(list, x => x.id);\nconsole.log(x); // [{id:3},{id:7}];\n```"
    ],
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "snippet:map-in-place"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "The array to be sorted."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "valuePicker",
        "description": "A function that when applied to each value of\nthe array returns another value to be used for the sorting. This function is\ncalled only once per value."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "reverse",
        "description": "Whether or not to reverse the sorting."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "The given array (for chaining convenience)."
    }
  },
  {
    "__docId__": 70,
    "kind": "file",
    "name": "src/to-diacritics-insensitive-regex.js",
    "content": "/**\r\n * Converts a given string to a regex that matches it in a diacritic-insensitive way.\r\n * \r\n * @param {string} string The string to be matched\r\n * \r\n * @return {RegExp} The regexp that matches the string in a diacritic-insensitive way\r\n * \r\n * @example\r\n * \r\n * ```\r\n * toDiacriticsInsensitiveRegex(\"resume\") === /r[EeÈèÉéÊêËë]s[UuÙùÚúÛûÜü]m[EeÈèÉéÊêËë]/i\r\n * ```\r\n */\r\nconst toDiacriticsInsensitiveRegex = (() => {\r\n    // Adapted from https://github.com/pocesar/js-diacritic-regex (thank you very much!)\r\n    const charsToEscape = \"-[]{}()*+!<=:?./\\\\^$|#,\";\r\n    const mappings = {\r\n        \"a\": \"AaÀàÁáÂâÃãÄä\", // \"a\": String.fromCharCode(65, 97, 192, 224, 193, 225, 194, 226, 195, 227, 196, 228),\r\n        \"c\": \"CcÇç\", // \"e\": String.fromCharCode(69, 101, 200, 232, 201, 233, 202, 234, 203, 235),\r\n        \"e\": \"EeÈèÉéÊêËë\", // \"i\": String.fromCharCode(73, 105, 204, 236, 205, 237, 206, 238, 207, 239),\r\n        \"i\": \"IiÌìÍíÎîÏï\", // \"o\": String.fromCharCode(79, 111, 210, 242, 211, 243, 212, 244, 213, 245, 214, 246),\r\n        \"n\": \"NnÑñ\", // \"n\": String.fromCharCode(78, 110, 209, 241),\r\n        \"o\": \"OoÒòÓóÔôÕõÖö\", // \"u\": String.fromCharCode(85, 117, 217, 249, 218, 250, 219, 251, 220, 252),\r\n        \"u\": \"UuÙùÚúÛûÜü\", // \"c\": String.fromCharCode(67, 99, 199, 231),\r\n        \"y\": \"YyÝýÿ\" // \"y\": String.fromCharCode(89, 121, 221, 253, 159, 255)\r\n    };\r\n    return string => {\r\n        const regexString = string.split(\"\").map(char => {\r\n            if (charsToEscape.indexOf(char) !== -1) return `\\\\${char}`;\r\n            for (const key in mappings) {\r\n                if (key === char || mappings[key].indexOf(char) !== -1) {\r\n                    return `[${mappings[key]}]`;\r\n                }\r\n            }\r\n            return char;\r\n        }).join(\"\");\r\n        return new RegExp(regexString, \"i\");\r\n    };\r\n})();\r\n\r\n/* test */ module.exports = {\r\n    snippet: toDiacriticsInsensitiveRegex,\r\n    snippetName: \"toDiacriticsInsensitiveRegex\",\r\n    snippetTest: t => {\r\n        t.is(toDiacriticsInsensitiveRegex(\"resume\").toString(), `/r[EeÈèÉéÊêËë]s[UuÙùÚúÛûÜü]m[EeÈèÉéÊêËë]/i`);\r\n        t.is(toDiacriticsInsensitiveRegex(\"a+b?\").toString(), `/[AaÀàÁáÂâÃãÄä]\\\\+b\\\\?/i`);\r\n        t.is(toDiacriticsInsensitiveRegex(\"match.me(\\\\'\\\\')\").toString(), `/m[AaÀàÁáÂâÃãÄä]t[CcÇç]h\\\\.m[EeÈèÉéÊêËë]\\\\(\\\\\\\\'\\\\\\\\'\\\\)/i`);\r\n    }\r\n};",
    "static": true,
    "longname": "src/to-diacritics-insensitive-regex.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 71,
    "kind": "variable",
    "name": "toDiacriticsInsensitiveRegex",
    "memberof": "src/to-diacritics-insensitive-regex.js",
    "static": true,
    "longname": "src/to-diacritics-insensitive-regex.js~toDiacriticsInsensitiveRegex",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/to-diacritics-insensitive-regex.js",
    "importStyle": null,
    "description": "Converts a given string to a regex that matches it in a diacritic-insensitive way.",
    "examples": [
      "\n```\ntoDiacriticsInsensitiveRegex(\"resume\") === /r[EeÈèÉéÊêËë]s[UuÙùÚúÛûÜü]m[EeÈèÉéÊêËë]/i\n```"
    ],
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "string",
        "description": "The string to be matched"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "RegExp"
      ],
      "spread": false,
      "description": "The regexp that matches the string in a diacritic-insensitive way"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "file",
    "name": "src/unzip.js",
    "content": "/**\n * Unzips a given zip file into the destination folder.\n * \n * @requires npm:extract-zip^1.6.7\n * @requires npm:fs-jetpack^2.2.0\n * \n * @param {string} zipFilePath The path to the zip file, as an\n * absolute path or a relative path to the given cwd (current\n * working directory).\n * @param {string} [destFolter=\".\"] The destination folder, into\n * which the unzipped files will be put, as an absolute path or\n * a relative path to the given cwd (current working directory).\n * Will be created if it does not exist.\n * @param {string} [cwd=\".\"] The reference path to be used for\n * internally computing the absolute paths of the first two\n * parameters. This parameter itself can be given as an absolute\n * path or a relative path to `process.cwd()`.\n * \n * @return {Promise} A promise that resolves when the unzipping is\n * complete as rejects if any error happens in the process.\n */\nconst unzip = function(zipFilePath, destFolder = \".\", cwd = \".\") {\n    const jetpack = require(\"fs-jetpack\");\n    const extract = require(\"extract-zip\");\n\n    const localJetpack = jetpack.cwd(cwd);\n    return localJetpack.dirAsync(destFolder).then(() => new Promise((resolve, reject) => {\n        extract(localJetpack.path(zipFilePath), { dir: localJetpack.path(destFolder) }, function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    }));\n};\n\n/* test */ module.exports = {\n    snippet: unzip,\n    snippetName: \"unzip\",\n    snippetTest: t => {\n        const jetpack = require(\"fs-jetpack\");\n        t.plan(3);\n        return unzip(\"test-fixtures/example-zip-file.zip\", \"test-temp\").then(() => {\n            t.is(jetpack.exists(\"test-temp/example-file.txt\"), \"file\");\n            t.is(jetpack.read(\"test-temp/example-file.txt\"), \"example-content\");\n            jetpack.remove(\"test-temp\");\n            t.pass();\n        });\n    }\n};",
    "static": true,
    "longname": "src/unzip.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 73,
    "kind": "function",
    "name": "unzip",
    "memberof": "src/unzip.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/unzip.js~unzip",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/unzip.js",
    "importStyle": null,
    "description": "Unzips a given zip file into the destination folder.",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@requires",
        "tagValue": "npm:extract-zip^1.6.7"
      },
      {
        "tagName": "@requires",
        "tagValue": "npm:fs-jetpack^2.2.0"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "zipFilePath",
        "description": "The path to the zip file, as an\nabsolute path or a relative path to the given cwd (current\nworking directory)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\".\"",
        "defaultRaw": ".",
        "name": "destFolter",
        "description": "The destination folder, into\nwhich the unzipped files will be put, as an absolute path or\na relative path to the given cwd (current working directory).\nWill be created if it does not exist."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\".\"",
        "defaultRaw": ".",
        "name": "cwd",
        "description": "The reference path to be used for\ninternally computing the absolute paths of the first two\nparameters. This parameter itself can be given as an absolute\npath or a relative path to `process.cwd()`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise that resolves when the unzipping is\ncomplete as rejects if any error happens in the process."
    }
  },
  {
    "__docId__": 74,
    "kind": "file",
    "name": "src/wait.js",
    "content": "/**\n * Get a promise that resolves after a given amount of milliseconds.\n * \n * @param {int} millis The amount of milliseconds to wait before resolving the promise.\n * @param {*} [value] A value to fulfill the promise with.\n * \n * @return {Promise} A promise that resolves after the given amount of milliseconds with\n * the given value (if given) or undefined (if not given).\n */\nconst wait = function(millis, value = undefined) {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve(value);\n        }, millis);\n    });\n};\n\n/* test */ module.exports = {\n    snippet: wait,\n    snippetName: \"wait\",\n    snippetTest: t => {\n        t.pass();\n    }\n};",
    "static": true,
    "longname": "src/wait.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 75,
    "kind": "function",
    "name": "wait",
    "memberof": "src/wait.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wait.js~wait",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/wait.js",
    "importStyle": null,
    "description": "Get a promise that resolves after a given amount of milliseconds.",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "millis",
        "description": "The amount of milliseconds to wait before resolving the promise."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "value",
        "description": "A value to fulfill the promise with."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise that resolves after the given amount of milliseconds with\nthe given value (if given) or undefined (if not given)."
    }
  },
  {
    "__docId__": 76,
    "kind": "file",
    "name": "src/zero-pad-left.js",
    "content": "/**\n * Convert the given value to string, adding zeros to the left of it\n * so that the resulting string has length equal to the given length\n * (or, if the number representation is longer than the given length,\n * simply return the number converted to string).\n * \n * @param {*} value The value to be converted (usually a number)\n * @param {int} length The desired length\n * \n * @return {string} A string representation of the value with\n * length greater than or equal to the given length.\n * \n * @example\n * \n * ```\n * zeroPadLeft(1234, 7); // \"0001234\"\n * zeroPadLeft(1234, 3); // \"1234\"\n * zeroPadLeft(\"Hello\", 9); // \"0000Hello\"\n * ```\n */\nconst zeroPadLeft = function(value, length) {\n    let str = \"\" + value;\n    while (str.length < length) str = \"0\" + str;\n    return str;\n};\n\n/* test */ module.exports = {\n    snippet: zeroPadLeft,\n    snippetName: \"zeroPadLeft\",\n    snippetTest: t => {\n        t.is(zeroPadLeft(1234, 7), \"0001234\");\n        t.is(zeroPadLeft(1234, 3), \"1234\");\n        t.is(zeroPadLeft(\"Hello\", 9), \"0000Hello\");\n    }\n};",
    "static": true,
    "longname": "src/zero-pad-left.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 77,
    "kind": "function",
    "name": "zeroPadLeft",
    "memberof": "src/zero-pad-left.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zero-pad-left.js~zeroPadLeft",
    "access": null,
    "export": false,
    "importPath": "papb-js-snippets/src/zero-pad-left.js",
    "importStyle": null,
    "description": "Convert the given value to string, adding zeros to the left of it\nso that the resulting string has length equal to the given length\n(or, if the number representation is longer than the given length,\nsimply return the number converted to string).",
    "examples": [
      "\n```\nzeroPadLeft(1234, 7); // \"0001234\"\nzeroPadLeft(1234, 3); // \"1234\"\nzeroPadLeft(\"Hello\", 9); // \"0000Hello\"\n```"
    ],
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The value to be converted (usually a number)"
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "length",
        "description": "The desired length"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A string representation of the value with\nlength greater than or equal to the given length."
    }
  }
]